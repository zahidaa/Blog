<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">
    <meta name="author" content="Waseem Akram">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="keywords" content="Researcher, Pentest, dev">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Posts" />
    <meta name="twitter:description" content="" />
    <meta property="og:title" content="Posts" />
    <meta property="og:description" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="/posts/" />
    <title>andorid application basics - Waseem Akram</title>
    <link rel="canonical" href="/blog">
    <link rel="preload" href="../fonts/forkawesome-webfont.woff2v=1.1.7" as="font" type="font/woff2" crossorigin>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/normalize.css" />
    <link rel="manifest" href="/js/manifest.json">
    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">
    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link href='https://unpkg.com/boxicons@2.1.2/css/boxicons.min.css' rel='stylesheet'>
    <link rel="alternate" type="application/rss+xml" href="../posts/index.xml" title="Waseem Akram" />
    <script defer src="https://twemoji.maxcdn.com/v/13.0.1/twemoji.min.js"></script>
    <!-- google Ads -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9670252621494000"
        crossorigin="anonymous"></script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0PCVFG8BNK"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'G-0PCVFG8BNK');
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9670252621494000"
        crossorigin="anonymous"></script>
    <!-- hackerwasii -->
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9670252621494000" data-ad-slot="1081579313"
        data-ad-format="auto" data-full-width-responsive="true"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</head>

<body class="colorscheme-auto" onload=" twemoji.parse(document.body); ">
    <div class="float-container">
        <a id="dark-mode-toggle" class="colorscheme-toggle">
            <i class='bx bx-adjust'></i>
        </a>
    </div>
    <main class="wrapper">
        <nav class="navigation">
            <section class="container">
                <a class="navigation-title" href="/">Waseem Akram</a>
                <input type="checkbox" id="menu-toggle" />
                <label class="menu-button float-right" for="menu-toggle">
                    <i class='bx bx-menu'></i>
                </label>
                <ul class="navigation-list">
                    <li class="navigation-item">
                        <a class="navigation-link" href="/whoami">üîé About</a>
                    </li>

                    <li class="navigation-item">
                        <a class="navigation-link" href="/posts/resources">üéâ Resources</a>
                    </li>

                    <li class="navigation-item">
                        <a class="navigation-link" href="/blog">üìö Blog</a>
                    </li>
                </ul>
            </section>
        </nav>
        <div class="content">
            <section class="container post">
                <article>
                    <header>
                        <div class="post-title">
                            <h1 class="title">
                                <a class="title-link" href="/posts/android-applications-basics">
                                    Andorid Applications Basics
                                </a>
                            </h1>
                        </div>
                        <div class="post-meta">
                            <div class="date">
                                <span class="posted-on">
                                    <i class='bx bxs-calendar'></i>
                                    <time datetime='2022-07-25T12:06:55&#43;01:00'>
                                        July 22, 2022
                                    </time>
                                </span>
                                <span class="reading-time">
                                    <i class='bx bx-time-five'></i>
                                    2-minute read
                                </span>
                            </div>
                            <div class="categories">
                                <i class='bx bxs-folder'></i>
                                <a href="/categories/categories">hacking</a>
                                <span class="separator">‚Ä¢</span>
                                <a href="/categories/categories">kali Linux</a>
                            </div>
                            <div class="tags">
                                <i class='bx bxs-purchase-tag'></i>
                                <span class="tag">
                                    <a href="/tags/tags">hacking</a>
                                </span>
                                <span class="separator">‚Ä¢</span>
                                <span class="tag">
                                    <a href="/tags/tags">android</a>
                                </span>
                            </div>
                        </div>
                    </header>
                    <div>
                        <h2>Table of Contents</h2>
                        <aside class="table-of-contents">
                            <nav id="TableOfContents">
                                <ul>
                                    <li><a href="#android-security-model">Android Security Model</a></li>
                                    <li><a href="#uid-separation">UID Separation</a></li>
                                    <li><a href="#uid-sharing">UID Sharing</a></li>
                                    <li><a href="#sand-boxing">Sandboxing</a>
                                        <ul>
                                            <li><a href="#permissions">Permissions</a></li>
                                        </ul>
                                    </li>
                                    <li><a href="#pre-installed-applications">Pre-Installed Applications</a></li>
                                    <li><a href="#rooting">Rooting</a>
                                        <ul>
                                            <li><a href="#roms">ROMs</a></li>
                                        </ul>
                                    </li>
                                    <li><a href="#implications">Implications</a></li>
                                    <li><a href="#android-application-fundamentals">Android Application Fundamentals</a>
                                    </li>
                                    <li><a href="#dalvik-smali">Dalvik & Smali</a></li>
                                    <li><a href="#intents">Intents</a>
                                        <ul>
                                            <li><a href="#intent-filter">Intent-Filter</a></li>
                                            <li><a href="#implicit-intents">Implicit Intents</a></li>
                                            <li><a href="#explicit-intents">Explicit Intents</a></li>
                                            <li><a href="#pending-intents">Pending Intents</a></li>
                                            <li><a href="#broadcast-intents">Broadcast Intents</a></li>
                                        </ul>
                                    </li>
                                    <li><a href="#sticky-broadcasts">Sticky Broadcasts</a></li>
                                    <li><a href="#deep-links-url-schemes">Deep links / URL schemes</a></li>
                                    <li><a href="#aidl">AIDL - Android Interface Definition Language</a></li>
                                    <li><a href="#messenger">Messenger</a></li>
                                    <li><a href="#components">Components</a></li>
                                    <li><a href="#app-subclass">Application Subclass</a></li>
                                </ul>
                            </nav>
                        </aside>
                        <p>
                            <h2 id="android-security-model">Android Security Model</h2>
                            <h4>There are two layers:</h4>
                            <ul>
                                <li>The <strong>OS</strong>, which keeps installed applications isolated from one
                                    another.</li>
                                <li>The <strong>application itself</strong>, which allows developers to <strong>expose
                                        certain functionalities</strong> and configures application capabilities.</li>
                            </ul>
                            <h2 id="uid-separation">UID Separation</h2>
                            <strong>Each application is assigned a specific User ID</strong>. This is done during the
                            installation of the
                            app so <strong>the app can only interact with files owned by its User ID or shared
                                files</strong>. Therefore,
                            only the app itself, certain components of the OS and the root user can access the apps
                            data.
                        </p>
                        <hr>
                        <h2 id="uid-sharing">UID Sharing</h2>
                        <p>
                            <strong>Two applications can be configured to use the same UID</strong>. This can be useful
                            to share
                            information, but if one of them is compromised the data of both applications will be
                            compromised. This is why this behaviour is <strong>discourage.
                                To share the same UID, applications must define the same
                                <code>android:sharedUserId</code> value in their
                                manifests</strong>
                        </p>
                        <hr>
                        <h2 id="sand-boxing">Sandboxing</h2>
                        <p>
                            The <strong>Android Application Sandbox</strong> allows to run <strong>each
                                application</strong> as a<strong> separate process under a
                                separate user ID</strong>. Each process has its own virtual machine, so an app‚Äôs code
                            runs in
                            isolation from other apps.
                            From Android 5.0(L) <strong>SELinux</strong> is enforced. Basically, SELinux denied all
                            process interactions
                            and then created policies to <strong>allow only the expected interactions between
                                them.</strong>
                        </p>
                        <hr>
                        <h2 id="permissions">Permissions</h2>
                        <p>
                            When you installs an <strong>app and it ask for permissions</strong>, the app is asking for
                            the permissions
                            configured in the <strong><code>uses-permission</code></strong> elements in the
                            <strong>AndroidManifest.xml</strong> file. The
                            uses-permission element indicates the name of the requested permission inside the
                            <strong>name
                                attribute</strong>. It also has the <strong>maxSdkVersion</strong> attribute which stops
                            asking for permissions on
                            versions higher than the one specified.
                            Note that android applications don't need to ask for all the permissions at the beginning,
                            they can also ask for <strong>permissions dynamically</strong> but all the permissions must
                            be declared in
                            the <strong>manifest.</strong>
                            When an app exposes functionality it can limit the <strong>access to only apps that have a
                                specified
                                permission.</strong>
                            A permission element has three attributes:
                            <ul>
                                <li>The <strong>name</strong> of the permission.</li>
                                <li>The <strong>permission-group</strong> attribute, which allows for grouping related
                                    permissions.</li>
                                <li>The <strong>protection-level</strong> which indicates how the permissions are
                                    granted. There are four types:</li>
                                <ul>
                                    <li><strong>Normal:</strong> Used when there are no known threats to the app. The
                                        user is <strong> not required to approve it.</strong></li>
                                    <li><strong>Dangerous:</strong> Indicates the permission grants the requesting
                                        application some <strong>elevated access. Users are requested to approve
                                            them.</strong></li>
                                    <li><strong>Signature:</strong> Only <strong>apps signed by the same certificate as
                                            the one</strong> exporting the component can be granted permission. This is
                                        the strongest type of protection.</li>
                                    <li><strong>SignatureOrSystem:</strong> Only <strong>apps signed by the same
                                            certificate as the one</strong> exporting the component or <strong>apps
                                            running with system-level access</strong> can be granted permissions</li>
                                </ul>
                            </ul>
                        </p>
                        <hr>
                        <h2 id="pre-installed-applications">Pre-Installed Applications</h2>
                        <p>
                            These apps are generally found in the <code>/system/app</code> or
                            <code>/system/priv-app</code> directories and some
                            of them are <strong>optimised</strong> (you may not even find the <code>classes.dex</code>
                            file). Theses applications are
                            worth checking because some times they are <strong>running with too many
                                permissions</strong>(as root).
                            <ul>
                                <li>The ones shipped with the <strong>AOSP</strong>(Android OpenSource
                                    Project)<strong>ROM</strong></li>
                                <li>Added by the device <strong>manufacturer</strong></li>
                                <li>Added by the cell <strong>phone provider</strong> (if purchased from them)</li>
                            </ul>
                        </p>
                        <hr>
                        <h2 id="rooting">Rooting</h2>
                        <p>
                            In order to obtain root access into a physical android device you generally need to
                            <strong>exploit</strong>
                            1 or 2 <strong>vulnerabilities</strong> which use to be <strong>specific</strong> for the
                            <strong>device</strong> and <strong>version.</strong>
                            Once the exploit has worked, usually the Linux <code>su</code> binary is copied into a
                            location specified
                            in the user's PATH env variable like <code>/system/xbin.</code>
                            <br>
                            Once the <code>su</code> binary is configured, another Android app is used to interface with
                            the su
                            binary and <strong>process requests for root access</strong> like <strong>Superuser</strong>
                            and <strong>SuperSU</strong> (available in Google
                            Play store).
                            <details><span style="color: rgb(86, 22, 196); font-weight: bold;">Note that the
                                    rooting process is very dangerous and can damage severely the device</span>
                            </details>
                        </p>
                        <hr>
                        <h2 id="roms">ROMs</h2>
                        <p>
                            It's possible to <strong>replace the OS installing a custom firmware</strong>. Doing this
                            it's possible to
                            extend the usefulness of an old device, bypass software restrictions or gain access to the
                            latest Android code.
                            <strong>OmniROM</strong> and <strong>LineageOS</strong> are two of the most popular
                            firmwares to use.
                            <br>
                            <span style="color: rgb(86, 22, 196); font-weight: bold;">Note that not always is necessary
                                to root the device to install a custom firmware. Some
                                manufacturers allow the unlocking of their bootloaders in a well-documented and safe
                                manner.</span>
                        </p>
                        <h2 id="implications">Implications</h2>
                        <p>
                            Once a device is rooted, any app could request access as root. If a malicious application
                            gets it, it can will have access to almost everything and it will be able to damage the
                            phone.
                        </p>
                        <hr>
                        <h2 id="android-application-fundamentals">Android Application Fundamentals</h2>
                        <p>
                            <h3><strong>Fundamentals Review</strong></h3>
                            <ul>
                                <li>Android applications are in the APK file format. <strong>APK is basically a ZIP
                                        file</strong>. (You can rename the file extension to .zip and use unzip to open
                                    and see its contents.)</li>
                                <li>APK Contents (Not exhaustive)</li>
                                <ul>
                                    <li><strong>AndroidManifest.xml</strong></li>
                                    <li>resources.arsc/strings.xml</li>
                                    <li>resources.arsc: a file containing precompiled resources, such as binary XML for
                                        example.</li>
                                    <ul>
                                        <li>res/xml/files_paths.xml</li>
                                    </ul>
                                    <li>META-INF/</li>
                                    <ul>
                                        <li>Certificate lives here!</li>
                                    </ul>
                                    <li><strong>classes.dex</strong></li>
                                    <ul>
                                        <li>Dalvik bytecode for application in the DEX file format. <strong>This is the
                                                Java (or Kotlin) code</strong>compiled that the application will run by
                                            default.</li>
                                    </ul>
                                    <li>lib/</li>
                                    <ul>
                                        <li>Native libraries for the application, by default, live here! Under the lib/
                                            directory, there are the cpu-specific directories.</li>
                                        <ul>
                                            <li><code>armeabi:</code> compiled code for all ARM based processors only
                                            </li>
                                            <li><code>armeabi-v7a:</code> compiled code for all ARMv7 and above based
                                                processors only</li>
                                            <li><code>x86:</code> compiled code for X86</li>
                                            <li><code>mips:</code> compiled code for MIPS processors only</li>
                                        </ul>
                                    </ul>
                                    <li>assets/</li>
                                    <ul>
                                        <li>Any other files that may be needed by the app.</li>
                                        <li>Additional native libraries or DEX files may be included here. This can
                                            happen especially when malware authors want to try and ‚Äúhide‚Äù additional
                                            code, native or Dalvik, by not including it in the default locations.</li>
                                    </ul>
                                </ul>
                                <li>res/</li>
                                <ul>
                                    <li>the directory containing resources not compiled into resources.arsc</li>
                                </ul>
                            </ul>
                        </p>
                        <hr>
                        <h2 id="dalvik-smali">Dalvik & Smali</h2>
                        <p>
                            Most Android applications are written in Java. Kotlin is also supported and interoperable
                            with Java. For ease, for the rest of this workshop, when I refer to ‚ÄúJava‚Äù, you can assume
                            that I mean ‚ÄúJava or Kotlin‚Äù. Instead of the Java code being run in Java Virtual Machine
                            (JVM) like desktop applications, in Android, the Java is compiled to the _Dalvik Executable
                            (DEX) bytecode_** format**. For earlier versions of Android, the bytecode was translated by
                            the Dalvik virtual machine. For more recent versions of Android, the Android Runtime (ART)
                            is used.
                            If developers, write in Java and the code is compiled to DEX bytecode, to reverse engineer,
                            we work the opposite direction./
                        </p>
                        <p><img src="/images/DevelopersFlow.jpg" alt="Dev flows"></p>
                        <p>Flowchart of Developer's process. Java to DEX bytecode</p>
                        <br>
                        <p><img src="/images/ReversersFlow.jpg" alt="Dev flows"></p>
                        <p>Flowchart of Reverse Engineer's process. DEX bytecode to SMALI to Decompiled Java</p>
                        <p>
                            Smali is the human readable version of Dalvik bytecode. Technically, Smali and baksmali are
                            the name of the tools (assembler and disassembler, respectively), but in Android, we often
                            use the term ‚ÄúSmali‚Äù to refer to instructions. If you‚Äôve done reverse engineering or
                            computer architecture on compiled C/C++ code. SMALI is like the assembly language: between
                            the higher level source code and the bytecode.
                        </p>
                        <hr>
                        <h2 id="intents">Intents</h2>
                        <p>
                            Intents are the primary means by which Android apps communicate between their components or
                            with other apps. These message objects can also carry data between apps or component,
                            similar to how GET/POST requests are used in HTTP communications.
                            <br>
                            So an Intent is basically a message that is passed between components. Intents can be
                            directed to specific components or apps, or can be sent without a specific recipient.
                            To be simple Intent can be used:
                            <ul>
                                <li>To start an Activity, typically opening a user interface for an app</li>
                                <li>As broadcasts to inform the system and apps of changes</li>
                                <li>To start, stop, and communicate with a background service</li>
                                <li>To access data via ContentProviders</li>
                                <li>As callbacks to handle events</li>
                            </ul>
                            <br>
                            Improper implementation could result in data leakage, restricted functions being called and
                            program flow being manipulated.
                        </p>
                        <hr>
                        <h2 id="intent-filter">Intent-Filter</h2>
                        <p>
                            An Intent Filter specify the <strong>types of Intent that an activity, service, or Broadcast
                                Receiver can respond to.</strong> It specifies what an activity or service can do and
                            what types of
                            broadcasts a Receiver can handle. It allows the corresponding component to receive Intents
                            of the declared type. Intent Filters are typically <strong>defined via the
                                AndroidManifest.xml file.</strong>
                            For <strong>Broadcast Receiver</strong> it is also possible to define them in
                            <strong>coding.</strong> An Intent Filter is
                            defined by its category, action and data filters. It can also contain additional metadata.br
                            <br>
                            <p>
                                In Android, an activity/service/content provider/broadcast receiver is
                                <strong>public</strong> when
                                <code>exported</code> is set to <code>true</code> but a component is <strong>also
                                    public</strong> if the </strong>manifest specifies an
                                Intent filter</strong> for it. However,
                                developers can explicitly make components private (regardless of any intent filters)
                                by setting the ** <code>exported</code> attribute to <code>false</code>** for each
                                component in the manifest file.
                                Developers can also set the <code>permission</code> attribute to <code>require a certain
                                    permission to
                                    access</code> the component, thereby restricting access to the component.
                            </p>
                        </p>
                        <hr>
                        <h2 id="implicit-intents">Implicit Intents</h2>
                        <p>
                            Intents are programatically created using an Intent constructor:
                            <div class="highlight">
                                <pre tabindex="0"
                                    style="color:#e5e5e5;background-color: #22272E;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="color: #87623F;">Intent</span> email <span style="color: #87623F;">=</span> <span style="color: #499C78;">new</span> <span style="color: #87623F;">Intent</span>(</code><span style="color: #87623F;">Intent</span>.ACTION_SEND, <span style="color: #87623F;">Uri</span>.<span style="color: #803336;">parse</span>(<span style="color: #477dd4">"mailto:"</span>));</pre>
                            </div>
                            The <strong>Action</strong> of the previously declared intent is
                            <strong>ACTION_SEND</strong> and the Extra is a mailto <strong>Uri</strong>
                            (the Extra if the extra information the intent is expecting).
                            <br>
                            This intent should be declared inside the manifest as in the following example:
                            <div class="highlight">
                                <pre tabindex="0"
                                    style="color:#e5e5e5;background-color: #22272E;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">&lt;<span style="color: #477dd4">activity</span> <span style="color: #b47234">android:</span><span style="color: #da8735;">name</span>="<span style="color: #5cbe99;">ShareActivity</span>"&gt; <br>     &lt;<span style="color: #477dd4">intent-filter</span>&gt;<br>        &lt;<span style="color: #477dd4">action </span><span style="color: #b47234">android:</span><span style="color: #da8735;">name</span>="<span style="color: #5cbe99;">android.intent.action.SEND</span>" /&gt;<br>        &lt;<span style="color: #477dd4">category </span><span style="color: #b47234">android:</span><span style="color: #da8735;">name</span>="<span style="color: #5cbe99;">android.intent.category.DEFAULT</span>"/&gt;<br>     &lt;/<span style="color: #477dd4">intent-filter</span>&gt;<br>&lt;/<span style="color: #477dd4">activity</span>&gt;</code></pre>
                            </div>
                            An intent-filter needs to match the <strong>action</strong>, <strong>data</strong> and
                            <strong>category</strong> to receive a message.
                            <br><br>
                            The "Intent resolution" process determine which app should receive each message. This
                            process considers the priority attribute, which can be set in the intent-filter declaration,
                            and the one with the higher priority will be selected. This priority can be set between
                            -1000 and 1000 and applications can use the SYSTEM_HIGH_PRIORITY value. If a conflict
                            arises, a "choser" Window appears so the user can decide.
                        </p>
                        <hr>
                        <h2 id="explicit-intents">Explicit Intents</h2>
                        <p>
                            An explicit intent specifies the class name it's targeting:
                            <div class="highlight">
                                <pre tabindex="0"
                                    style="color:#e5e5e5;background-color: #22272E;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="color: #da8735;">Intent</span> downloadIntent <span style="color: #da8735;">=</span> <span style="color: #56c597;">new</span>(<span style="color: #56c597;">this</span>, <span style="color: #da8735;">DownloadService</span>.<span style="color: #56c597;">class</span>)<span style="color: #da8735;">:</span></code></pre>
                            </div>
                            In other applications in order to access to the previously declared intent you can use:
                            <div class="highlight">
                                <pre tabindex="0"
                                    style="color:#e5e5e5;background-color: #22272E;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="color: #da8735;">Intent</span> intent <span style="color: #da8735;">=</span> <span style="color: #56c597;">new</span> <span style="color: #da8735;">Intent</span>();<br>intent.<span style="color: #ca3b49;">setClassName</span>(<span style="color: #477dd4;">"com.other.app"</span>,<span style="color: #477dd4;"> "com.other.app.ServiceName"</span>);<br>context.<span style="color: #ca3b49;">startService</span>(intent);</code></pre>
                            </div>
                        </p>
                        <hr>
                        <h2 id="pending-intents">Pending Intents</h2>
                        <p>
                            These allow other applications to take actions on behalf of your application, using your
                            app's identity and permissions. Constructing a Pending Intent it should be specified an
                            intent and the action to perform. If the declared intent isn't Explicit (doesn't declare
                            which intent can call it) a malicious application could perform the declared action on
                            behalf of the victim app. Moreover, if an action isn't specified, the malicious app will be
                            able to do any action on behalf the victim.
                        </p>
                        <hr>
                        <h2 id="broadcast-intents">Broadcast Intents</h2>
                        <p>
                            Unlike the previous intents, which are only received by one app, broadcast intents can be
                            received by multiple apps. However, from API version 14, it's possible to specify the app
                            that should receive the message using Intent.set Package. <br>
                            Alternatively it's also possible to specify a permission when sending the broadcast. The
                            receiver app will need to have that permission.
                            <br>
                            There are two types of Broadcasts: Normal (asynchronous) and Ordered (synchronous). The
                            order is base on the configured priority within the receiver element. Each app can process,
                            relay or drop the Broadcast. <br>
                            It's possible to send a broadcast using the function **sendBroadcast(intent,
                            receiverPermission) ** from the Context class. <br>
                            You could also use the function sendBroadcast from the LocalBroadCastManager ensures the
                            message never leaves the app. Using this you won't even need to export a receiver component.
                        </p>
                        <hr>
                        <h2 id="sticky-broadcasts">Sticky Broadcasts</h2>
                        <p>
                            This kind of Broadcasts can be accessed long after they were sent. <br>
                            These were deprecated in API level 21 and it's recommended to not use them. <br>
                            They allow any application to sniff the data, but also to modify it. <br><br>
                            If you find functions containing the word "sticky" like sendStickyBroadcast or
                            sendStickyBroadcastAsUser, check the impact and try to remove them.
                        </p>
                        <hr>
                        <h2 id="deep-links-url-schemes">Deep links / URL schemes</h2>
                        <p>
                            <strong>Deep links allow to trigger an Intent via URL.</strong> An application can declare
                            an URL schema inside and activity so every time the Android device try to <strong>access an
                                address using that schema</strong> the applications activity will be called:
                            <p><img src="/images/url-scheme.png" alt="deep-links-url-schemes"></p>
                            In this case the scheme in <code><strong>myapp://</strong></code> (note also the
                            <code><strong>category BROWSABLE</strong></code>)
                            <p>If inside the <strong><code>intent-filter</strong></code> you find something like this:
                            </p>
                            <p><img src="/images/url-scheme-example.png" alt="url-scheme-example"></p>
                            <p>Then, it's expecting something like
                                <strong><code>http://www.example.com/gizmos</strong></code></p>
                            <p>
                                In this case you could try to abuse the functionality creating a web with the following
                                payloads. It will try to navigate to arbitrary pages and try to execute JS:
                                <div class="highlight">
                                    <pre tabindex="0"
                                        style="color:#e5e5e5;background-color: #22272E;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">&lt;<span style="color: #477dd4;">a</span> <span style="color: #da8735;">href</span>="<span style="color: #56c597;">example://gizmos/https://google.com</span>"&gt;click here&lt;/<span style="color: #477dd4;">a</span>&gt;<br>&lt;<span style="color: #477dd4;">a</span> <span style="color: #da8735;">href</span>="<span style="color: #56c597;">example://gizmos/javascript://%250dalert(1)</span>"&gt;click here&lt;/<span style="color: #477dd4;">a</span>&gt;</code></pre>
                                </div>
                                <p>
                                    In order to find the <strong>code that will be executed in the App</strong>, go to
                                    the activity called by the deeplink and search the function
                                    <code><strong>onNewIntent.</strong></code>
                                    <p><img src="/images/new-intent.png" alt="new-intent"></p>
                                    <p>Learn how to <a href="/posts/android/android-app-pentesting" target="_blank"
                                            style="color: #1fc3f5; text-decoration: none;">call deep links without using
                                            HTML pages</a></p>
                                    <hr>
                                </p>
                            </p>
                        </p>
                        <h2 id="aidl">AIDL - Android Interface Definition Language</h2>
                        <p>
                            The Android Interface Definition Language (AIDL) allows you to define the programming
                            interface that both the client and service agree upon in order to communicate with each
                            other using interprocess communication (IPC). On Android, one process cannot normally access
                            the memory of another process. So to talk, they need to decompose their objects into
                            primitives that the operating system can understand, and marshall the objects across that
                            boundary for you. The code to do that marshalling is tedious to write, so Android handles it
                            for you with AIDL.).
                        </p>
                        <p>
                            Services using AIDL are referred to as Bound Services. In the Service's class you will find
                            the onBind method. This is where the interaction begins so it's initial part of the code to
                            review looking for potential vulnerabilities.
                        </p>
                        <p>
                            A bound service is the server in a client-server interface. It allows components (such as
                            activities) to bind to the service, send requests, receive responses, and perform
                            interprocess communication (IPC). A bound service typically lives only while it serves
                            another application component and does not run in the background indefinitely.
                        </p>
                        <h2 id="messenger">Messenger</h2>
                        <p>
                            A Messenger is another type of IPC mechanism. Since the Messenger is also a "Bound Service",
                            the data passed from the client app is also processed through the onBind method. So, the
                            code review should start on this method and you should look for the invocation of sensitive
                            functionality or unsafe handling of data.
                        </p>
                        <h2 id="binder">Binder</h2>
                        <p>
                            It's weird to find a Binder class directly invoked as it's much easier to use AIDL (which
                            abstracts the Binder class). However, it's good to know that Binder is a kernel-level driver
                            which moves data from one process's memory to another's (<a
                                href="https://www.youtube.com/watch?v=O-UHvFjxwZ8"
                                target="_blank">https://www.youtube.com/watch?v=O-UHvFjxwZ8</a>)
                        </p>
                        <hr>
                        <h2 id="components">Components</h2>
                        <p>These include: <strong>Activities, Services, Broadcast Receivers and Providers.</strong></p>
                        <h2>Launcher Activity and other activities</h2>
                        <p>
                            An Android activity is one screen of the Android app's user interface. In that way an
                            Android activity is very similar to windows in a desktop application. An Android app may
                            contain one or more activities, meaning one or more screens.
                        </p>
                        <p>
                            The launcher activity is what most people think of as the entry point to an Android
                            application. The launcher activity is the activity that is started when a user clicks on the
                            icon for an application. You can determine the launcher activity by looking at the
                            application‚Äôs manifest. The launcher activity will have the following MAIN and LAUNCHER
                            intents listed.
                        </p>
                        <p>
                            Keep in mind that not every application will have a launcher activity, especially apps
                            without a UI. Examples of applications without a UI (and thus a launcher activity) are
                            pre-installed applications that perform services in the background, such as voicemail.
                            <div class="highlight">
                                <pre tabindex="0"
                                    style="color:#e5e5e5;background-color: #22272E;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">&lt;<span style="color: #477dd4">activity</span> <span style="color: #b47234">android:</span><span style="color: #da8735;">name</span>="<span style="color: #5cbe99;">.LauncherActivity</span>"&gt; <br>     &lt;<span style="color: #477dd4">intent-filter</span>&gt;<br>        &lt;<span style="color: #477dd4">action </span><span style="color: #b47234">android:</span><span style="color: #da8735;">name</span>="<span style="color: #5cbe99;">android.intent.action.MAIN</span>" /&gt;<br>        &lt;<span style="color: #477dd4">category </span><span style="color: #b47234">android:</span><span style="color: #da8735;">name</span>="<span style="color: #5cbe99;">android.intent.category.LAUNCHER</span>"/&gt;<br>     &lt;/<span style="color: #477dd4">intent-filter</span>&gt;<br>&lt;/<span style="color: #477dd4">activity</span>&gt;</code></pre>
                            </div>
                            <p>
                                Activities can be exported allowing other processes on the device to launch the
                                activity. By default, they aren't exported but you can export them setting:
                                <div class="highlight">
                                    <pre tabindex="0"
                                        style="color:#e5e5e5;background-color: #22272E;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">&lt;<span style="color: #477dd4;">service</span><span style="color: #b47234"> android:</span><span style="color: #da8735;">name</span>="<span style="color: #56c597;">.ExampleExportedService</span><span style="color: #b47234"> android:</span><span style="color: #da8735;">exported</span>="<span style="color: #56c597;">true</span></span>"/&gt;</code></pre>
                                </div>
                                <p>
                                    Note that the ability to <strong>bypass activity protections isn't always a
                                        vulnerability</strong>,
                                    you need to check to which data you have obtained access.
                                </p>
                                <p>
                                    Also, <strong>some activities returns data to a caller</strong>. In these scenarios
                                    you need to
                                    search for the <strong><code>setResult</code></strong> method and check the data
                                    that is passed into the Intent
                                    parameter. <strong>If it's sensitive data you may have an information leakage
                                        vulnerability</strong>
                                    and it's exploitable with apps capable of communicating with the Activity.
                                </p>
                                <p>
                                    <strong>The code of an activity starts with the <code>onCreate</code>
                                        method.</strong>
                                </p>
                            </p>
                        </p>
                        <hr>
                        <h2 id="app-subclass">Application Subclass</h2>
                        <p>
                            Android applications can define a <strong>subclass</strong> of <a
                                href="https://developer.android.com/reference/android/app/Application"
                                target="_blank">Application</a>. Applications can, but do not have to define a custom
                            subclass of Application. If an Android app defines an Application subclass, <strong>this
                                class is instantiated prior to any other class in the application.</strong>
                            <p>
                                If the <strong><code>attachBaseContext</code></strong> method is defined in the
                                Application subclass, it is called first, before the
                                <strong><code>onCreate</code></strong> method.
                            </p>
                        </p>
                        <hr>
                    </div>
                </article>
            </section>
        </div>
        <footer class="footer">
            <section class="container">
                ¬©2021 - 2022 Waseem Akram ¬∑ Made with <a href="https://github.com/evildevill/" target="_blank">üíñ</a>
            </section>
        </footer>
    </main>
    <script src="/js/dark-mode.js"></script>
</body>

</html>
